#!/bin/sh

# Resolve directory of the script to find libs
SCRIPT_SRC_DIR="$(cd "$(dirname "$0")" && pwd)"
LIB_DIR="$SCRIPT_SRC_DIR/lib"

# If not found in relative path (e.g. installed in a bin directory), try relative to prefix or system paths
if [ ! -d "$LIB_DIR" ]; then
    # Try relative to prefix: ../lib/clickup-cli
    RELATIVE_LIB_DIR="$(cd "$SCRIPT_SRC_DIR/../lib/clickup-cli" 2>/dev/null && pwd)"
    if [ -d "$RELATIVE_LIB_DIR" ]; then
        LIB_DIR="$RELATIVE_LIB_DIR"
    elif [ -d "$HOME/.local/lib/clickup-cli" ]; then
        LIB_DIR="$HOME/.local/lib/clickup-cli"
    elif [ -d "/usr/local/lib/clickup-cli" ]; then
        LIB_DIR="/usr/local/lib/clickup-cli"
    else
        echo "Error: Could not find library directory at $LIB_DIR or standard system paths" >&2
        exit 1
    fi
fi

. "$LIB_DIR/config.sh"
. "$LIB_DIR/logger.sh"
. "$LIB_DIR/api.sh"

createClickupCliFolderIfNeeded
loadConfig

BASE_URL="${BASE_URL:-https://api.clickup.com/api/v3}"
API_TOKEN="${API_TOKEN}"
WORKSPACE_ID="${DEFAULT_WORKSPACE_ID}"
CHANNEL_ID="${DEFAULT_CHANNEL_ID}"
VERBOSE=0

# Parse command-line arguments with support for flags and subcommands
parseArguments() {
    if [ "$#" -lt 1 ]; then
        showUsage
        exit 1
    fi

    # Parse global flags first
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                showUsage
                exit 0
                ;;
            -w|--workspace)
                if [ -z "$2" ]; then
                    log "Error: --workspace requires a value"
                    exit 1
                fi
                WORKSPACE_ID="$2"
                shift 2
                ;;
            -c|--channel)
                if [ -z "$2" ]; then
                    log "Error: --channel requires a value"
                    exit 1
                fi
                CHANNEL_ID="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=1
                shift
                ;;
            -*)
                log "Error: Unknown option $1"
                showUsage
                exit 1
                ;;
            *)
                # First non-flag argument is the command
                break
                ;;
        esac
    done

    if [ $# -lt 1 ]; then
        log "Error: No command specified"
        showUsage
        exit 1
    fi

    # Dispatch to subcommand handlers
    local command="$1"
    shift
    
    case "$command" in
        send)
            handleSendCommand "$@"
            ;;
        list)
            handleListCommand "$@"
            ;;
        configure)
            handleConfigureCommand "$@"
            ;;
        help)
            showUsage
            exit 0
            ;;
        *)
            log "Error: Unknown command '$command'"
            showUsage
            exit 1
            ;;
    esac
}

# Handle 'configure' command
handleConfigureCommand() {
    interactiveConfigure
}

# Handle 'send' subcommand with flexible syntax
handleSendCommand() {
    local subcommand="$1"
    shift
    
    case "$subcommand" in
        message|msg)
            handleSendMessage "$@"
            ;;
        *)
            log "Error: Unknown send subcommand '$subcommand'"
            echo "Usage: $0 send message <text>"
            exit 1
            ;;
    esac
}

# Handle sending messages with flexible argument parsing
handleSendMessage() {
    local message=""

    # Parse message arguments - support quoted strings and concatenation
    while [ $# -gt 0 ]; do
        case "$1" in
            to)
                shift
                if [ -n "$1" ]; then
                    CHANNEL_ID="$1"
                    shift
                fi
                ;;
            in)
                shift
                if [ -n "$1" ]; then
                    WORKSPACE_ID="$1"
                    shift
                fi
                ;;
            *)
                # Accumulate message text
                if [ -z "$message" ]; then
                    message="$1"
                else
                    message="$message $1"
                fi
                shift
                ;;
        esac
    done
    
    if [ -z "$message" ]; then
        log "Error: No message provided"
        echo "Usage: $0 send message <text> [to <channel>] [in <workspace>]"
        exit 1
    fi
    
    if [ -z "$WORKSPACE_ID" ] || [ -z "$CHANNEL_ID" ]; then
        log "Error: Workspace ID and Channel ID are required"
        log "Use --workspace and --channel flags or environment variables"
        exit 1
    fi
    
    sendMessageToChannel "$message"
}

sendMessageToChannel() {
    local message="$1"
    
    # Validate inputs
    if [ -z "$message" ]; then
        log "Error: Message cannot be empty"
        return 1
    fi
    
    if [ -z "$WORKSPACE_ID" ]; then
        log "Error: Workspace ID is required"
        return 1
    fi
    
    if [ -z "$CHANNEL_ID" ]; then
        log "Error: Channel ID is required"
        return 1
    fi
    
    if [ -z "$API_TOKEN" ]; then
        log "Error: API_TOKEN environment variable is required"
        return 1
    fi
    
    debug "Sending message to workspace:$WORKSPACE_ID channel:$CHANNEL_ID"
    debug "Message: $message"
    
    local endpoint="workspaces/$WORKSPACE_ID/chat/channels/$CHANNEL_ID/messages"
    local data
    
    if isJQAvailable; then
        data=$(jq -n --arg text "$message" '{type: "message", content_format: "text/plain", content: $text}')
    else
        local escapedMessage=$(escapeJson "$message")
        data="{\"type\": \"message\", \"content_format\": \"text/plain\", \"content\": \"$escapedMessage\"}"
    fi
    
    local response
    response=$(apiCall "$endpoint" "POST" "$data")
    local result=$?
    
    if [ $result -eq 0 ]; then
        log "Message sent successfully"
        if [ "$VERBOSE" = "1" ] && [ -n "$response" ]; then
            debug "Response: $response"
        fi
    else
        log "Failed to send message"
    fi
    
    return $result
}

# Handle 'list' subcommand
handleListCommand() {
    local subcommand="$1"
    shift
    
    case "$subcommand" in
        workspaces)
            handleListWorkspaces
            ;;
        channels)
            handleListChannels
            ;;
        *)
            log "Error: Unknown list subcommand '$subcommand'"
            echo "Usage: $0 list [workspaces|channels]"
            exit 1
            ;;
    esac
}

handleListWorkspaces() {
    local response
    response=$(apiCall "team" "GET" "")
    
    if [ $? -ne 0 ]; then
        return 1
    fi

    echo "Workspaces:"
    echo "ID\t\tName"
    echo "--\t\t----"
    
    if isJQAvailable; then
        echo "$response" | jq -r '.teams[] | "\(.id)\t\(.name)"'
    else
        # Basic fallback for simple JSON structure
        # Assumes standard formatting, highly brittle
        echo "$response" | tr '}' '\n' | grep -o '"id":"[^"]*","name":"[^"]*"' | sed 's/"id":"\([^"]*\)","name":"\([^"]*\)"/\1\t\2/'
    fi
}

handleListChannels() {
    if [ -z "$WORKSPACE_ID" ]; then
        log "Error: Workspace ID is required to list channels"
        log "Use --workspace flag or set DEFAULT_WORKSPACE_ID"
        return 1
    fi

    local response
    response=$(apiCall "workspaces/$WORKSPACE_ID/chat/channels" "GET" "")
    
    if [ $? -ne 0 ]; then
        return 1
    fi

    echo "Channels (Chat) in Workspace $WORKSPACE_ID:"
    echo "ID\t\tName"
    echo "--\t\t----"
    
    if isJQAvailable; then
        echo "$response" | jq -r '.channels[] | "\(.id)\t\(.name)"'
    else
         # Basic fallback
        echo "$response" | tr '}' '\n' | grep -o '"id":"[^"]*","name":"[^"]*"' | sed 's/"id":"\([^"]*\)","name":"\([^"]*\)"/\1\t\2/'
    fi
}

showUsage() {
    echo "ClickUp CLI - Command Line Interface for ClickUp API"
    echo
    echo "USAGE:"
    echo "  $0 [OPTIONS] <COMMAND> [ARGS...]"
    echo
    echo "GLOBAL OPTIONS:"
    echo "  -h, --help              Show this help message"
    echo "  -w, --workspace <ID>    Workspace ID (overrides DEFAULT_WORKSPACE_ID)"
    echo "  -c, --channel <ID>      Channel ID (overrides DEFAULT_CHANNEL_ID)"
    echo "  -v, --verbose           Enable verbose output"
    echo
    echo "COMMANDS:"
    echo "  send message <text>     Send a message to a channel"
    echo "    [to <channel>]          Specify channel ID inline"
    echo "    [in <workspace>]        Specify workspace ID inline"
    echo
    echo "  list workspaces         List available workspaces"
    echo "  list channels           List channels in workspace"
    echo
    echo "  configure               Interactive configuration"
    echo
    echo "  help                    Show this help message"
    echo
    echo "EXAMPLES:"
    echo "  # Send message using environment variables"
    echo "  $0 send message \"Hello, world!\""
    echo
    echo "  # Send message with explicit workspace and channel"
    echo "  $0 --workspace 123 --channel 456 send message \"Hello!\""
    echo
    echo "  # Send message with inline parameters"
    echo "  $0 send message \"Hello!\" to 456 in 123"
    echo
    echo "  # Mixed usage"
    echo "  $0 --workspace 123 send message \"Hello!\" to 456"
    echo
    echo "ENVIRONMENT VARIABLES:"
    echo "  BASE_URL                Base URL for ClickUp API"
    echo "                          (default: https://api.clickup.com/api/v3)"
    echo "  API_TOKEN               Your ClickUp API token (required)"
    echo "  DEFAULT_WORKSPACE_ID    Default workspace ID"
    echo "  DEFAULT_CHANNEL_ID     Default channel ID"
    echo
    echo "For more information, visit: https://clickup.com/api"
}

parseArguments "$@"