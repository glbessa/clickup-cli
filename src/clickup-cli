#!/bin/bash

# Resolve directory of the script to find libs
SCRIPT_SRC_DIR="$(cd "$(dirname "$0")" && pwd)"
LIB_DIR="$SCRIPT_SRC_DIR/lib"

# If not found in relative path (e.g. installed in a bin directory), try relative to prefix or system paths
if [ ! -d "$LIB_DIR" ]; then
    # Try relative to prefix: ../lib/clickup-cli
    RELATIVE_LIB_DIR="$(cd "$SCRIPT_SRC_DIR/../lib/clickup-cli" 2>/dev/null && pwd)"
    if [ -d "$RELATIVE_LIB_DIR" ]; then
        LIB_DIR="$RELATIVE_LIB_DIR"
    elif [ -d "$HOME/.local/lib/clickup-cli" ]; then
        LIB_DIR="$HOME/.local/lib/clickup-cli"
    elif [ -d "/usr/local/lib/clickup-cli" ]; then
        LIB_DIR="/usr/local/lib/clickup-cli"
    else
        echo "Error: Could not find library directory at $LIB_DIR or standard system paths" >&2
        exit 1
    fi
fi

. "$LIB_DIR/config.sh"
. "$LIB_DIR/logger.sh"
. "$LIB_DIR/api.sh"

createClickupCliFolderIfNeeded
loadConfig

BASE_URL="${BASE_URL:-https://api.clickup.com/api/v3}"
API_TOKEN="${API_TOKEN}"
WORKSPACE_ID="${DEFAULT_WORKSPACE_ID}"
CHANNEL_ID="${DEFAULT_CHANNEL_ID}"
VERBOSE=0

# Parse command-line arguments with support for flags and subcommands
parseArguments() {
    if [ "$#" -lt 1 ]; then
        showUsage
        exit 1
    fi

    # Parse global flags first
    while [ $# -gt 0 ]; do
        case "$1" in
            -h|--help)
                showUsage
                exit 0
                ;;
            -w|--workspace)
                if [ -z "$2" ]; then
                    log "Error: --workspace requires a value"
                    exit 1
                fi
                WORKSPACE_ID="$2"
                shift 2
                ;;
            -c|--channel)
                if [ -z "$2" ]; then
                    log "Error: --channel requires a value"
                    exit 1
                fi
                CHANNEL_ID="$2"
                shift 2
                ;;
            -v|--verbose)
                VERBOSE=1
                shift
                ;;
            -*)
                log "Error: Unknown option $1"
                showUsage
                exit 1
                ;;
            *)
                # First non-flag argument is the command
                break
                ;;
        esac
    done

    if [ $# -lt 1 ]; then
        log "Error: No command specified"
        showUsage
        exit 1
    fi

    # Dispatch to subcommand handlers
    local command="$1"
    shift
    
    case "$command" in
        send)
            handleSendCommand "$@"
            ;;
        list)
            handleListCommand "$@"
            ;;
        create)
            handleCreateCommand "$@"
            ;;
        update)
            handleUpdateCommand "$@"
            ;;
        delete)
            handleDeleteCommand "$@"
            ;;
        show)
            handleShowCommand "$@"
            ;;
        configure)
            handleConfigureCommand "$@"
            ;;
        help)
            showUsage
            exit 0
            ;;
        *)
            log "Error: Unknown command '$command'"
            showUsage
            exit 1
            ;;
    esac
}

# Handle 'configure' command
handleConfigureCommand() {
    interactiveConfigure
}

# Handle 'send' subcommand with flexible syntax
handleSendCommand() {
    local subcommand="$1"
    shift
    
    case "$subcommand" in
        message|msg)
            handleSendMessage "$@"
            ;;
        *)
            log "Error: Unknown send subcommand '$subcommand'"
            echo "Usage: $0 send message <text>"
            exit 1
            ;;
    esac
}

# Handle sending messages with flexible argument parsing
handleSendMessage() {
    local message=""

    # Parse message arguments - support quoted strings and concatenation
    while [ $# -gt 0 ]; do
        case "$1" in
            to)
                shift
                if [ -n "$1" ]; then
                    CHANNEL_ID="$1"
                    shift
                fi
                ;;
            in)
                shift
                if [ -n "$1" ]; then
                    WORKSPACE_ID="$1"
                    shift
                fi
                ;;
            *)
                # Accumulate message text
                if [ -z "$message" ]; then
                    message="$1"
                else
                    message="$message $1"
                fi
                shift
                ;;
        esac
    done
    
    if [ -z "$message" ]; then
        log "Error: No message provided"
        echo "Usage: $0 send message <text> [to <channel>] [in <workspace>]"
        exit 1
    fi
    
    if [ -z "$WORKSPACE_ID" ] || [ -z "$CHANNEL_ID" ]; then
        log "Error: Workspace ID and Channel ID are required"
        log "Use --workspace and --channel flags or environment variables"
        exit 1
    fi
    
    sendMessageToChannel "$message"
}

sendMessageToChannel() {
    local message="$1"
    
    # Validate inputs
    if [ -z "$message" ]; then
        log "Error: Message cannot be empty"
        return 1
    fi
    
    if [ -z "$WORKSPACE_ID" ]; then
        log "Error: Workspace ID is required"
        return 1
    fi
    
    if [ -z "$CHANNEL_ID" ]; then
        log "Error: Channel ID is required"
        return 1
    fi
    
    if [ -z "$API_TOKEN" ]; then
        log "Error: API_TOKEN environment variable is required"
        return 1
    fi
    
    debug "Sending message to workspace:$WORKSPACE_ID channel:$CHANNEL_ID"
    debug "Message: $message"
    
    local endpoint="workspaces/$WORKSPACE_ID/chat/channels/$CHANNEL_ID/messages"
    local data
    
    if isJQAvailable; then
        data=$(jq -n --arg text "$message" '{type: "message", content_format: "text/plain", content: $text}')
    else
        local escapedMessage=$(escapeJson "$message")
        data="{\"type\": \"message\", \"content_format\": \"text/plain\", \"content\": \"$escapedMessage\"}"
    fi
    
    local response
    response=$(apiCall "$endpoint" "POST" "$data")
    local result=$?
    
    if [ $result -eq 0 ]; then
        log "Message sent successfully"
        if [ "$VERBOSE" = "1" ] && [ -n "$response" ]; then
            debug "Response: $response"
        fi
    else
        log "Failed to send message"
    fi
    
    return $result
}

# Handle 'list' subcommand
handleListCommand() {
    local subcommand="$1"
    shift
    
    case "$subcommand" in
        workspaces|teams)
            handleListWorkspaces
            ;;
        spaces)
            handleListSpaces "$@"
            ;;
        folders)
            handleListFolders "$@"
            ;;
        lists)
            handleListLists "$@"
            ;;
        tasks)
            handleListTasks "$@"
            ;;
        channels)
            handleListChannels
            ;;
        *)
            log "Error: Unknown list subcommand '$subcommand'"
            echo "Usage: $0 list [workspaces|spaces|folders|lists|channels]"
            exit 1
            ;;
    esac
}

handleListSpaces() {
    local team_id="${WORKSPACE_ID}"
    if [ -z "$team_id" ]; then
        log "Error: Workspace (Team) ID is required. Use --workspace or set DEFAULT_WORKSPACE_ID."
        return 1
    fi

    local response
    response=$(apiCall "team/$team_id/space" "GET" "")
    
    if [ $? -ne 0 ]; then return 1; fi

    echo "Spaces in Workspace $team_id:"
    echo -e "ID\t\tName"
    echo -e "--\t\t----"
    
    if isJQAvailable; then
        echo "$response" | jq -r '.spaces[] | "\(.id)\t\(.name)"'
    else
        echo "$response" | tr '}' '\n' | grep -o '"id":"[^"]*","name":"[^"]*"' | sed 's/"id":"\([^"]*\)","name":"\([^"]*\)"/\1\t\2/'
    fi
}

handleListFolders() {
    local space_id=""
    
    while [ $# -gt 0 ]; do
        case "$1" in
            --space) space_id="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    if [ -z "$space_id" ]; then
        log "Error: --space <id> is required to list folders"
        return 1
    fi

    local response
    response=$(apiCall "space/$space_id/folder" "GET" "")
    
    if [ $? -ne 0 ]; then return 1; fi

    echo "Folders in Space $space_id:"
    echo -e "ID\t\tName"
    echo -e "--\t\t----"
    
    if isJQAvailable; then
        echo "$response" | jq -r '.folders[] | "\(.id)\t\(.name)"'
    else
        echo "$response" | tr '}' '\n' | grep -o '"id":"[^"]*","name":"[^"]*"' | sed 's/"id":"\([^"]*\)","name":"\([^"]*\)"/\1\t\2/'
    fi
}

handleListLists() {
    local space_id=""
    local folder_id=""
    
    while [ $# -gt 0 ]; do
        case "$1" in
            --space) space_id="$2"; shift 2 ;;
            --folder) folder_id="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    local endpoint=""
    local context=""
    if [ -n "$folder_id" ]; then
        endpoint="folder/$folder_id/list"
        context="Folder $folder_id"
    elif [ -n "$space_id" ]; then
        endpoint="space/$space_id/list"
        context="Space $space_id"
    else
        log "Error: --space <id> or --folder <id> is required to list lists"
        return 1
    fi

    local response
    response=$(apiCall "$endpoint" "GET" "")
    
    if [ $? -ne 0 ]; then return 1; fi

    echo "Lists in $context:"
    echo -e "ID\t\tName"
    echo -e "--\t\t----"
    
    if isJQAvailable; then
        echo "$response" | jq -r '.lists[] | "\(.id)\t\(.name)"'
    else
        echo "$response" | tr '}' '\n' | grep -o '"id":"[^"]*","name":"[^"]*"' | sed 's/"id":"\([^"]*\)","name":"\([^"]*\)"/\1\t\2/'
    fi
}

handleListTasks() {
    local list_id=""
    
    while [ $# -gt 0 ]; do
        case "$1" in
            --list|-l) list_id="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    if [ -z "$list_id" ]; then
        log "Error: --list <id> is required to list tasks"
        return 1
    fi

    local response
    response=$(apiCall "list/$list_id/task" "GET" "")
    
    if [ $? -ne 0 ]; then return 1; fi

    echo "Tasks in List $list_id:"
    printf "%-15s %-10s %-10s %s\n" "ID" "STATUS" "PRIORITY" "NAME"
    printf "%-15s %-10s %-10s %s\n" "--" "------" "--------" "----"
    
    if isJQAvailable; then
        echo "$response" | jq -r '.tasks[] | "\(.id)\t\(.status.status)\t\(.priority.priority // "none")\t\(.name)"' | while IFS=$'\t' read -r id status prio name; do
            printf "%-15s %-10s %-10s %s\n" "$id" "$status" "$prio" "$name"
        done
    else
        # Very basic fallback
        echo "$response" | tr '}' '\n' | grep -o '"id":"[^"]*","name":"[^"]*"' | sed 's/"id":"\([^"]*\)","name":"\([^"]*\)"/\1\t\2/'
    fi
}

# Handle 'show' subcommand
handleShowCommand() {
    local subcommand="$1"
    shift
    
    case "$subcommand" in
        task)
            handleShowTask "$@"
            ;;
        *)
            log "Error: Unknown show subcommand '$subcommand'"
            echo "Usage: $0 show task <id>"
            exit 1
            ;;
    esac
}

handleShowTask() {
    local task_id="$1"
    if [ -z "$task_id" ]; then
        log "Error: Task ID is required"
        return 1
    fi

    local response
    response=$(apiCall "task/$task_id" "GET" "")
    if [ $? -ne 0 ]; then return 1; fi

    if isJQAvailable; then
        echo "$response" | jq -r '
            "ID: \(.id)\n" +
            "Name: \(.name)\n" +
            "Status: \(.status.status)\n" +
            "Priority: \(.priority.priority // "none")\n" +
            "URL: \(.url)\n" +
            "Description:\n\(.description // "No description")"
        '
    else
        echo "$response"
    fi
}

# Handle 'update' subcommand
handleUpdateCommand() {
    local subcommand="$1"
    shift
    
    case "$subcommand" in
        task)
            handleUpdateTask "$@"
            ;;
        *)
            log "Error: Unknown update subcommand '$subcommand'"
            echo "Usage: $0 update task <id> [options]"
            exit 1
            ;;
    esac
}

handleUpdateTask() {
    local task_id="$1"
    shift
    
    if [ -z "$task_id" ]; then
        log "Error: Task ID is required"
        return 1
    fi

    local name=""
    local description=""
    local priority=""
    local status=""

    while [ $# -gt 0 ]; do
        case "$1" in
            --name|-n) name="$2"; shift 2 ;;
            --description|-d) description="$2"; shift 2 ;;
            --priority|-p) priority="$2"; shift 2 ;;
            --status|-s) status="$2"; shift 2 ;;
            *) shift ;;
        esac
    done

    local data="{"
    local first=1
    
    if [ -n "$name" ]; then
        data="$data \"name\": \"$(escapeJson "$name")\""
        first=0
    fi
    if [ -n "$description" ]; then
        [ $first -eq 0 ] && data="$data,"
        data="$data \"description\": \"$(escapeJson "$description")\""
        first=0
    fi
    if [ -n "$priority" ]; then
        [ $first -eq 0 ] && data="$data,"
        data="$data \"priority\": $priority"
        first=0
    fi
    if [ -n "$status" ]; then
        [ $first -eq 0 ] && data="$data,"
        data="$data \"status\": \"$status\""
        first=0
    fi
    data="$data }"

    if [ $first -eq 1 ]; then
        log "Error: No fields to update provided"
        return 1
    fi

    apiCall "task/$task_id" "PUT" "$data" >/dev/null
    if [ $? -eq 0 ]; then
        log "Task $task_id updated successfully"
    else
        log "Failed to update task $task_id"
    fi
}

# Handle 'delete' subcommand
handleDeleteCommand() {
    local subcommand="$1"
    shift
    
    case "$subcommand" in
        task)
            handleDeleteTask "$@"
            ;;
        *)
            log "Error: Unknown delete subcommand '$subcommand'"
            echo "Usage: $0 delete task <id>"
            exit 1
            ;;
    esac
}

handleDeleteTask() {
    local task_id="$1"
    local force=0
    
    if [ "$2" = "-y" ] || [ "$2" = "--yes" ]; then
        force=1
    fi

    if [ -z "$task_id" ]; then
        log "Error: Task ID is required"
        return 1
    fi

    if [ $force -eq 0 ]; then
        printf "Are you sure you want to delete task $task_id? [y/N] "
        read confirm
        if [[ ! "$confirm" =~ ^[yY] ]]; then
            echo "Aborted."
            return 0
        fi
    fi

    apiCall "task/$task_id" "DELETE" "" >/dev/null
    if [ $? -eq 0 ]; then
        log "Task $task_id deleted successfully"
    else
        log "Failed to delete task $task_id"
    fi
}

# Handle 'create' subcommand
handleCreateCommand() {
    local subcommand="$1"
    shift
    
    case "$subcommand" in
        task)
            handleCreateTask "$@"
            ;;
        *)
            log "Error: Unknown create subcommand '$subcommand'"
            echo "Usage: $0 create task <name> --list <id> [options]"
            exit 1
            ;;
    esac
}

handleCreateTask() {
    local name=""
    local list_id=""
    local description=""
    local priority=""
    local status=""

    # First argument is the task name
    if [ $# -gt 0 ] && [[ ! "$1" =~ ^- ]]; then
        name="$1"
        shift
    fi

    while [ $# -gt 0 ]; do
        case "$1" in
            --list|-l) list_id="$2"; shift 2 ;;
            --description|-d) description="$2"; shift 2 ;;
            --priority|-p) priority="$2"; shift 2 ;;
            --status|-s) status="$2"; shift 2 ;;
            *) 
                if [ -z "$name" ]; then
                    name="$1"
                else
                    name="$name $1"
                fi
                shift 
                ;;
        esac
    done

    if [ -z "$name" ]; then
        log "Error: Task name is required"
        return 1
    fi

    if [ -z "$list_id" ]; then
        log "Error: List ID is required (--list <id>)"
        return 1
    fi

    debug "Creating task '$name' in list $list_id"

    local data
    if isJQAvailable; then
        data=$(jq -n \
            --arg name "$name" \
            --arg desc "$description" \
            --arg prio "$priority" \
            --arg status "$status" \
            '{name: $name, description: $desc}')
        
        # Add priority and status if provided
        [ -n "$priority" ] && data=$(echo "$data" | jq --arg prio "$priority" '.priority = ($prio | tonumber)')
        [ -n "$status" ] && data=$(echo "$data" | jq --arg status "$status" '.status = $status')
    else
        local escapedName=$(escapeJson "$name")
        local escapedDesc=$(escapeJson "$description")
        data="{\"name\": \"$escapedName\", \"description\": \"$escapedDesc\""
        [ -n "$priority" ] && data="$data, \"priority\": $priority"
        [ -n "$status" ] && data="$data, \"status\": \"$status\""
        data="$data}"
    fi

    local response
    response=$(apiCall "list/$list_id/task" "POST" "$data")
    
    if [ $? -eq 0 ]; then
        log "Task created successfully"
        if isJQAvailable; then
            local task_id=$(echo "$response" | jq -r '.id')
            local task_url=$(echo "$response" | jq -r '.url')
            echo "ID: $task_id"
            echo "URL: $task_url"
        fi
    else
        log "Failed to create task"
    fi
}

handleListWorkspaces() {
    local response
    response=$(apiCall "team" "GET" "")
    
    if [ $? -ne 0 ]; then
        return 1
    fi

    echo "Workspaces:"
    echo "ID\t\tName"
    echo "--\t\t----"
    
    if isJQAvailable; then
        echo "$response" | jq -r '.teams[] | "\(.id)\t\(.name)"'
    else
        # Basic fallback for simple JSON structure
        # Assumes standard formatting, highly brittle
        echo "$response" | tr '}' '\n' | grep -o '"id":"[^"]*","name":"[^"]*"' | sed 's/"id":"\([^"]*\)","name":"\([^"]*\)"/\1\t\2/'
    fi
}

handleListChannels() {
    if [ -z "$WORKSPACE_ID" ]; then
        log "Error: Workspace ID is required to list channels"
        log "Use --workspace flag or set DEFAULT_WORKSPACE_ID"
        return 1
    fi

    local response
    response=$(apiCall "workspaces/$WORKSPACE_ID/chat/channels" "GET" "")
    
    if [ $? -ne 0 ]; then
        return 1
    fi

    echo "Channels (Chat) in Workspace $WORKSPACE_ID:"
    echo "ID\t\tName"
    echo "--\t\t----"
    
    if isJQAvailable; then
        echo "$response" | jq -r '.channels[] | "\(.id)\t\(.name)"'
    else
         # Basic fallback
        echo "$response" | tr '}' '\n' | grep -o '"id":"[^"]*","name":"[^"]*"' | sed 's/"id":"\([^"]*\)","name":"\([^"]*\)"/\1\t\2/'
    fi
}

showUsage() {
    echo "ClickUp CLI - Command Line Interface for ClickUp API"
    echo
    echo "USAGE:"
    echo "  $0 [OPTIONS] <COMMAND> [ARGS...]"
    echo
    echo "GLOBAL OPTIONS:"
    echo "  -h, --help              Show this help message"
    echo "  -w, --workspace <ID>    Workspace ID (overrides DEFAULT_WORKSPACE_ID)"
    echo "  -c, --channel <ID>      Channel ID (overrides DEFAULT_CHANNEL_ID)"
    echo "  -v, --verbose           Enable verbose output"
    echo
    echo "COMMANDS:"
    echo "  send message <text>     Send a message to a channel"
    echo "    [to <channel>]          Specify channel ID inline"
    echo "    [in <workspace>]        Specify workspace ID inline"
    echo
    echo "  list workspaces         List available workspaces"
    echo "  list spaces             List spaces in workspace"
    echo "  list folders --space <id> List folders in space"
    echo "  list lists --space <id>  List lists in space"
    echo "  list lists --folder <id> List lists in folder"
    echo "  list tasks --list <id>  List tasks in a list"
    echo "  list channels           List channels in workspace"
    echo
    echo "  show task <id>          Show task details"
    echo
    echo "  create task <name> --list <id> [options]"
    echo "    OPTIONS:"
    echo "      -d, --description <text>  Task description"
    echo "      -p, --priority <1-4>      Priority (1: Urgent, 2: High, 3: Normal, 4: Low)"
    echo "      -s, --status <name>       Initial status (e.g., \"to do\")"
    echo
    echo "  update task <id> [options]"
    echo "    OPTIONS:"
    echo "      -n, --name <text>         New task name"
    echo "      -d, --description <text>  New description"
    echo "      -p, --priority <1-4>      New priority"
    echo "      -s, --status <name>       New status"
    echo
    echo "  delete task <id> [-y]     Delete a task"
    echo
    echo "  configure               Interactive configuration"
    echo
    echo "  help                    Show this help message"
    echo
    echo "EXAMPLES:"
    echo "  # Send message using environment variables"
    echo "  $0 send message \"Hello, world!\""
    echo
    echo "  # Send message with explicit workspace and channel"
    echo "  $0 --workspace 123 --channel 456 send message \"Hello!\""
    echo
    echo "  # Send message with inline parameters"
    echo "  $0 send message \"Hello!\" to 456 in 123"
    echo
    echo "  # Mixed usage"
    echo "  $0 --workspace 123 send message \"Hello!\" to 456"
    echo
    echo "ENVIRONMENT VARIABLES:"
    echo "  BASE_URL                Base URL for ClickUp API"
    echo "                          (default: https://api.clickup.com/api/v3)"
    echo "  API_TOKEN               Your ClickUp API token (required)"
    echo "  DEFAULT_WORKSPACE_ID    Default workspace ID"
    echo "  DEFAULT_CHANNEL_ID     Default channel ID"
    echo
    echo "For more information, visit: https://clickup.com/api"
}

parseArguments "$@"